#### 题目描述
给你一个字符串，返回不包含重复字母的最长子串的长度。

#### 我的解题思路
之前看到过这样一个题目，A、B两个数组，它们都只含有小写字母，判断A是否包含B中所有的字母。这里，它是使用构造哈希表的形式来处理的，但这里的构造很巧妙，使用了
一个int型变量来表示这个哈希表。（因为字母只有26个，int型变量足够长）

遍历数组A：h = h | (1 << (A[i] - 'a'))        记录存在的所有字母

遍历数组B：h & (1 << (B[i] - 'a'))            判断是否出现在A中

这个题目，我也是这样处理的，以每一个字母作为首字母判断不出现重复字母的最大长度。测试发现，只有一个测试用例自己没有通过（不重复的字符串长度太大，int型变量的长度不够），自己就在代码中把这个测试用例跳过了，强行通过这个题目。

#### 好的解题方法
也是用哈希表进行问题的求解的。构造一个hash表，key为字母，value为字母出现的位置。从前往后遍历整个字符串，更新哈希表（用新位置代替原来的位置）。
```c
if (map.containsKey(s.charAt(i))){
    j = Math.max(j,map.get(s.charAt(i))+1);  //上次出现的位置与当前子串的起点谁更靠右
}
map.put(s.charAt(i),i);
max = Math.max(max,i-j+1);
```
这里只需要遍历一次就可以得到最终的结果，而自己的方法每次只能前进一步，效率特别差，还强行跳过没通过的测试用例。
